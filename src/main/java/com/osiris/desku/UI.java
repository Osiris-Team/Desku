package com.osiris.desku;

import com.badlogic.gdx.scenes.scene2d.Actor;
import com.kotcrab.vis.ui.widget.VisWindow;
import com.osiris.desku.swing.events.LoadStateChange;
import com.osiris.desku.ui.Component;
import com.osiris.events.Event;
import com.osiris.jlib.logger.AL;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;

import java.awt.*;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Consumer;

/**
 * Native window with HTML content that is generated by provided {@link Route}.
 */
public class UI extends VisWindow {
    private static final ReentrantLock access = new ReentrantLock();
    private static volatile UI current = null;
    public volatile boolean isLoading = true;
    /**
     * Relevant when wanting HTML load state of {@link #browser}.
     */
    public final Event<LoadStateChange> onLoadStateChanged = new Event<>();
    /**
     * Last loaded html.
     */
    public final Route route;
    public final Component<?> content;
    /**
     * Not thread safe, access inside synchronized block.
     */
    public final HashMap<String, List<Component<?>>> listenersAndComps = new HashMap<>();
    public UI(Route route) throws IOException {
        this(route, false, 70, 60);
    }

    public UI(Route route, boolean isTransparent, int widthPercent, int heightPercent) throws IOException {
        super(App.name);
        setFillParent(true);
        setMovable(false);

        access.lock();
        current = this;

        this.route = route;
        this.content = route.loadContent();
        onLoadStateChanged.addAction((e) -> {
            if(e.isLoading) return;
            isLoading = false;
        });

        current = null;
        access.unlock();

        init("file:///" + snapshotToTempFile().getAbsolutePath(), isTransparent, widthPercent, heightPercent);
    }

    /**
     * Always null, except when inside... <br>
     * - {@link #access(Runnable)} <br>
     * - {@link #accessAsync(Runnable)} <br>
     * - constructor {@link #UI(Route, boolean, int, int)} when generating this UIs' HTML  for the first time. <br>
     * - any triggered JavaScript event that was registered via {@link #registerJSListener(String, Component, Consumer)}. <br>
     */
    public static UI current() {
        return current;
    }

    /**
     * Access this window synchronously now.
     * Also sets {@link #current} to this window.
     */
    public UI access(Runnable code) {
        access.lock();
        current = this;
        code.run();
        current = null;
        access.unlock();
        return this;
    }

    /**
     * Access this window synchronously, but later in another thread.
     * Also sets {@link #current} to this window.
     */
    public UI accessAsync(Runnable code) {
        Component.executor.execute(() -> {
            access(code);
        });
        return this;
    }

    /**
     * To display a simple browser window, it suffices completely to create an
     * instance of the class CefBrowser and to assign its UI component to your
     * application (e.g. to your content pane).
     * But to be more verbose, this CTOR keeps an instance of each object on the
     * way to the browser UI.
     */
    private void init(String startURL, boolean isTransparent, int widthPercent, int heightPercent) {
        try {
            long ms = System.currentTimeMillis();
            AL.info("Starting new window with url: " + startURL + " transparent: " + isTransparent + " width: " + widthPercent + "% height: " + heightPercent + "%");
            AL.info("Please stand by...");
            App.windows.add(this);




            AL.info("Init took " + (System.currentTimeMillis() - ms) + "ms for " + this);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public void close() {
        App.windows.remove(this);
    }

    /**
     * Creates a snapshot of the current UI (the full HTML page) <br>
     * and returns it as {@link Document} for further processing. <br>
     * Note that changes to it won't be reflected in the actual UI.
     */
    public Document getSnapshot() {
        Document html = route.getDocument();
        Element outlet = html.getElementById("outlet");
        content.updateAll();
        outlet.appendChild(content.actor);
        return html;
    }

    public File getDir() {
        // TODO in testing this resolves to the same directory after restarting even though it should be a new one
        // this results in cached files in that directory like images not getting updated, if changed.
        File dir = new File(App.tempDir + "/" + Integer.toHexString(hashCode()));
        dir.mkdirs();
        return dir;
    }

    /**
     * @see #snapshotToTempFile(Document)
     */
    public File snapshotToTempFile() throws IOException {
        return snapshotToTempFile(null);
    }

    /**
     * Creates a snapshot and writes the HTML to a file in the temp folder of the current user. <br>
     * If the path for this route is "/persons/john" for example then the html file will be created at: <br>
     * {@link App#tempDir}/{@link #hashCode()}/persons/john.html <br>
     * Note that the hash code is in hex format.
     *
     * @return the generated html file.
     */
    public File snapshotToTempFile(Document snapshot) throws IOException {
        File file = new File(getDir()
                + (route.path.equals("/") ? "/root.html" : (route.path + ".html")));
        if (snapshot == null) snapshot = getSnapshot();

        // Create symbolic link in current folder to global-styles.css
        // Symbolic links can't be created in temp folder?
        File link = new File(file.getParentFile() + "/" + App.styles.getName());
        AL.info("Copy of global styles: " + link);
        synchronized (App.styles) {
            if (!link.exists()) {
                link.getParentFile().mkdirs();
                link.createNewFile();
            }
            Files.copy(App.styles.toPath(), link.toPath(), StandardCopyOption.REPLACE_EXISTING);
        }
        Element elLink = new Element("link");
        elLink.attr("rel", "stylesheet");
        elLink.attr("href", App.styles.getName());
        snapshot.getElementsByTag("head").get(0).appendChild(elLink);

        // Write html to temp file
        AL.info("Generate: " + file);
        file.getParentFile().mkdirs();
        if (!file.exists()) file.createNewFile();
        Files.write(file.toPath(), snapshot.outerHtml().getBytes(StandardCharsets.UTF_8));
        return file;
    }

    /**
     * @see #width(int)
     */
    public void widthFull() {
        width(100);
    }

    /**
     * This invalidates the container and thus to see changes in the UI
     * make sure execute {@link java.awt.Component#revalidate()} manually.
     *
     * @param widthPercent 0 to 100% of the parent size (screen if null).
     */
    public void width(int widthPercent) {
        updateWidth(getParent(), widthPercent);
    }

    /**
     * @see #height(int)
     */
    public void heightFull() {
        height(100);
    }

    /**
     * This invalidates the container and thus to see changes in the UI
     * make sure execute {@link java.awt.Component#revalidate()} manually.
     *
     * @param heightPercent 0 to 100% of the parent size (screen if null).
     */
    public void height(int heightPercent) {
        updateHeight(getParent(), heightPercent);
    }

    private void updateWidth(Actor parent, int widthPercent) {
        float parentWidth; // If no parent provided use the screen dimensions
        if (parent != null) parentWidth = parent.getWidth();
        else parentWidth =
                GraphicsEnvironment.isHeadless() ? 1920 // FHD
                        : Toolkit.getDefaultToolkit().getScreenSize().width;
        setSize((float) parentWidth / 100 * widthPercent, getHeight());
    }

    private void updateHeight(Actor parent, int heightPercent) {
        float parentHeight; // If no parent provided use the screen dimensions
        if (parent != null) parentHeight = parent.getHeight();
        else parentHeight =
                GraphicsEnvironment.isHeadless() ? 1080 // FHD
                        : Toolkit.getDefaultToolkit().getScreenSize().height;
        setSize(getWidth(), parentHeight / 100 * heightPercent);
    }

    public UI plusX(int x) {
        setX(getX() + x);
        return this;
    }

    public UI plusY(int y) {
        setY(getY() + y);
        return this;
    }

    public UI openDevTools() {
        setDebug(true);
        return this;
    }
}
