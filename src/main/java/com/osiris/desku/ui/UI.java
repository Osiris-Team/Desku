package com.osiris.desku.ui;

import com.osiris.desku.App;
import com.osiris.desku.Route;
import com.osiris.desku.Value;
import com.osiris.desku.WarnDoc;
import com.osiris.desku.ui.layout.Popup;
import com.osiris.desku.ui.utils.Event;
import com.osiris.desku.ui.utils.Rectangle;
import com.osiris.desku.ui.utils.UnsafePortChrome;
import com.osiris.jlib.logger.AL;
import org.java_websocket.WebSocket;
import org.java_websocket.handshake.ClientHandshake;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;

import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.net.ServerSocket;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;

/**
 * Native window with HTML content that is generated by provided {@link Route}. <br>
 * SHOULD NOT MAKE USE OF ANY JAVA APIs THAT ARE SPECIFIC TO A PLATFORM LIKE AWT <br>
 * TO ENSURE COMPATIBILITY ACROSS PLATFORMS.
 */
public abstract class UI {
    private static final Map<Thread, UI> threadsAndUIs = new HashMap<>();
    private final AtomicBoolean isLoading = new AtomicBoolean(true);
    /**
     * Relevant when wanting HTML load state, since we cant run JavaScript before the page is fully loaded.<br>
     * Boolean parameter isLoading, is true if still loading or false if finished loading.
     */
    public final com.osiris.events.Event<Boolean> onLoadStateChanged = new com.osiris.events.Event<>();
    /**
     * This allows the programmer to add components to a parent even if the parent is
     * not attached yet (out of order additions). However those additions will only be visible in Java
     * and later in the browser. <br>
     * Access using "synchronized (pendingAppends)" to ensure order.
     * 01.07.2025: Pending appends are only pending frontend UI updates, on the backend a component add gets directly executed when it happens.
     * Meaning the first send of the complete UI will attach everything in the right order.
     * Component additions after this first send will always be done on an existing/attached component from the first send.
     * Thus, this data structure is not needed.
     */
    //public final List<PendingAppend> pendingAppends = new ArrayList<>();
    /**
     * Last loaded html.
     */
    public Route route;
    public Component<?, ?> content;
    /**
     * Not thread safe, access inside synchronized block.
     */
    public final HashMap<String, List<Component<?, ?>>> listenersAndComps = new HashMap<>();
    public JSWebSocketServer webSocketServer = null;
    public HTTPServer httpServer;

    public UI(Route route) throws Exception {
        this(route, false, true, 70, 60);
    }

    //
    // Abstract methods that require implementation
    //

    public UI(Route route, boolean isTransparent, boolean isDecorated, int widthPercent, int heightPercent) throws Exception {
        startHTTPServer();
        startWebSocketServer();

        //load(route.getClass()); // Done in HTTPServer

        safeInit("http://" + App.domainName + ":" + httpServer.serverPort + (route.path.startsWith("/") ? "" : "/") + route.path,
                isTransparent, isDecorated, widthPercent, heightPercent);

    }

    /**
     * Always null, except when code is running inside... <br>
     * - {@link #access(Runnable)} <br>
     * - constructor {@link #UI(Route, boolean, boolean, int, int)} when generating this UIs' HTML  for the first time. <br>
     * - any triggered JavaScript event that was registered via {@link #registerJSListener(String, Component, Consumer)}. <br>
     * or {@link #set(UI, Thread...)} was called before.
     */
    public static UI get() {
        // Current code is not inside access(), thus we check the thread
        synchronized (threadsAndUIs) {
            return threadsAndUIs.get(Thread.currentThread());
        }
    }

    /**
     * Maps the provided threads to the provided UI, so that when calling
     * {@link UI#get()} inside those threads it returns the provided UI.
     */
    public static void set(UI ui, Thread... threads) {
        synchronized (threadsAndUIs) {
            for (Thread t : threads) {
                threadsAndUIs.put(t, ui);
            }
        }
    }

    public static void remove(Thread... threads) {
        synchronized (threadsAndUIs) {
            for (Thread t : threads) {
                threadsAndUIs.remove(t);
            }
        }
    }

    /**
     * Initialises/Displays the window and loads the HTML from the provided startURL.
     *
     * @param startURL      URL of the HTML content. Example: http://localhost or https://google.com or file:///ABSOLUTE_PATH_TO_HTML_FILE
     * @param isTransparent
     * @param isDecorated
     * @param widthPercent
     * @param heightPercent
     */
    public abstract void init(String startURL, boolean isTransparent, boolean isDecorated, int widthPercent, int heightPercent) throws Exception;

    /**
     * This invalidates the container and thus to see changes in the UI
     * make sure execute {@link java.awt.Component#revalidate()} manually.
     *
     * @param widthPercent 0 to 100% of the parent size (screen if null).
     */
    public abstract void width(int widthPercent) throws InterruptedException, InvocationTargetException;

    /**
     * This invalidates the container and thus to see changes in the UI
     * make sure execute {@link java.awt.Component#revalidate()} manually.
     *
     * @param heightPercent 0 to 100% of the parent size (screen if null).
     */
    public abstract void height(int heightPercent) throws InterruptedException, InvocationTargetException;

    /**
     * Moves the window on the X axis.
     *
     * @param x amount to add to current x value.
     */
    public abstract void plusX(int x) throws InterruptedException, InvocationTargetException;

    /**
     * Moves the window on the Y axis.
     *
     * @param y amount to add to current y value.
     */
    public abstract void plusY(int y) throws InterruptedException, InvocationTargetException;

    /**
     * @see #executeJavaScriptSafely(String, String, int)
     */
    public synchronized Event<JavaScriptResult> executeJavaScriptSafely(String jsCode) {
        return executeJavaScriptSafely(jsCode, "internal", 0);
    }

    /**
     * Executes {@link JSWebSocketServer#executeJavaScript(UI, Event, String)} only once the UI is loaded and after
     * some internals JS dependencies are loaded. In an orderly fashion. Might return data from JavaScript after fully executed. <br>
     * <br>
     * Note that internally a websocket connection between Java (server/this) and JavaScript (client/webview/browser) is used to pass over the JavaScript code, thus this method only works
     * if the UI/page is also provided by this application.
     * Meaning if this UI loaded an external / third-party site like google.com you must use {@link #executeJavaScript(String, String, int)} instead.
     *
     * @see #getSnapshot() internal JS dependencies are added here.
     */
    public synchronized Event<JavaScriptResult> executeJavaScriptSafely(String jsCode, String jsCodeSourceName, int jsCodeStartingLineNumber) {
        Event<JavaScriptResult> event = new Event<>(true);
        if(App.isInDepthDebugging) {
            Exception e = new Exception();
            var javaStackTrace = new StringWriter();
            e.printStackTrace(new PrintWriter(javaStackTrace));
            String finalJsCode = "/* javaStackTrace\n"+Value.escapeForJavaScript(javaStackTrace.toString())+"*/\n\n\n" + jsCode;
            runIfReadyOrLater(() -> {
                webSocketServer.executeJavaScript(this, event, finalJsCode);
            });
        } else{
            runIfReadyOrLater(() -> {
                webSocketServer.executeJavaScript(this, event, jsCode);
            });
        }
        return event;
    }

    /**
     * Executes JavaScript code now via some sort of native method to ensure its
     * directly ran inside the native webview, without workarounds. <br>
     * <br>
     * Only use if you know what you are doing, in 99% of cases use {@link #executeJavaScriptSafely(String)} instead!<br>
     * <br>
     * - this method may wait until execution finishes, OR NOT. <br>
     * - this method may execute after the HTML fully loaded, OR NOT. <br>
     * - this method may execute the code in an orderly, synchronous fashion, OR NOT.<br>
     * <br>
     * If you loaded an external page you can execute the JS code returned by {@link JSWebSocketServer#jsStartWebSocketClient(String, int)} from {@link #webSocketServer}
     * via this method to establish a connection which then lets you execute the safe version of this method which also supports returning data from JavaScript.
     *
     * @param jsCode                   JavaScript (JS) code.
     * @param jsCodeSourceName         file name of the JS code or identifier, only relevant for debugging, can be empty string.
     * @param jsCodeStartingLineNumber line number/position the JS code starts in, usually 1.
     */
    public abstract void executeJavaScript(String jsCode, String jsCodeSourceName, int jsCodeStartingLineNumber);

    /**
     * Maximizes this window if true, otherwise restores the previous state.
     */
    public abstract void maximize(boolean b) throws InterruptedException, InvocationTargetException;

    /**
     * Minimizes this window if true, otherwise restores the previous state.
     */
    public abstract void minimize(boolean b) throws InterruptedException, InvocationTargetException;

    /**
     * Puts this window into full-screen if true, otherwise restores the previous state.
     */
    public abstract void fullscreen(boolean b) throws InterruptedException, InvocationTargetException;

    /**
     * Adds a listener which gets executed when this windows size changes.
     */
    public abstract void onSizeChange(Consumer<Rectangle> code) throws InterruptedException, InvocationTargetException;

    public abstract Rectangle getScreenSize() throws InterruptedException, InvocationTargetException;

    public abstract Rectangle getScreenSizeWithoutTaskBar() throws InterruptedException, InvocationTargetException;

    //
    // Utility methods
    //

    /**
     * If true decorates the window, otherwise removes the decoration.
     */
    public abstract void decorate(boolean b) throws InterruptedException, InvocationTargetException;

    /**
     * If true sets this window to be on top of all other windows, otherwise restores the previous state.
     */
    public abstract void allwaysOnTop(boolean b) throws InterruptedException, InvocationTargetException;

    /**
     * If true focuses this window, otherwise loses focus.
     */
    public abstract void focus(boolean b) throws InterruptedException, InvocationTargetException;

    /**
     * Changes the windows background color. <br>
     * Also changes the background color of {@link #content} if not null. <br>
     *
     * @param hexColor example: "#FF0000FF" (first 2 digits are red, then green, then blue, then alpha/opacity where 00 is transparent and FF fully visible).
     */
    public abstract void background(String hexColor) throws InterruptedException, InvocationTargetException;

    /**
     * Executes JavaScript to navigate to another route. <br>
     * Note that {@link #z_internal_load(Class)} will be called by {@link #startWebSocketServer()}
     * and thus the content of this UI modified.
     */
    public void navigate(Class<? extends Route> routeClass) {
        Route route = null;
        for (Route r : App.routes) {
            if (r.getClass().equals(routeClass)) {
                route = r;
                break;
            }
        }
        if (route == null) { // Route was not registered
            AL.warn("Failed to navigate to page, since provided route '" + routeClass
                    + "' was not registered, aka not added to App.routes!", new Exception());
            return;
        }
        executeJavaScriptSafely("window.location.href = `" + route.path + "`;", "internal", 0);
    }

    public void reload() {
        executeJavaScriptSafely("window.location.reload();", "internal", 0);
    }

    /**
     * Access this window synchronously now.
     */
    public UI access(Runnable code) {
        UI ui = UI.get();
        if(ui != null){
            // Already within another access() thus we simply run the code
            // and leave the rest to the original access() call.
            code.run();
            return ui;
        }
        UI.set(this, Thread.currentThread());
        code.run();
        UI.remove(Thread.currentThread());
        return this;
    }

    public void safeInit(String startURL, boolean isTransparent, boolean isDecorated, int widthPercent, int heightPercent) {
        try {
            AL.debug(this.getClass(), "Starting new UI/window with url: " + startURL + " transparent: " + isTransparent + " width: " + widthPercent + "% height: " + heightPercent + "%");
            AL.debug(this.getClass(), "Waiting for it to finish loading... Please stand by...");
            long ms = System.currentTimeMillis();

            /**
             * {@link #startWebSocketServer()}
             */
            onLoadStateChanged.addAction((action, isLoading2) -> {
                synchronized (isLoading) {
                    if (!isLoading2) {
                        action.remove();
                        isLoading.set(false);
                    }
                }

            }, Exception::printStackTrace);

            App.uis.all.add(this);
            init(startURL, isTransparent, isDecorated, widthPercent, heightPercent);

            while (isLoading.get()) Thread.yield();

            AL.debug(this.getClass(), "Init took " + (System.currentTimeMillis() - ms) + "ms for " + this);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public void close() {
        App.uis.all.remove(this);
        try {
            webSocketServer.stop();
            AL.debug(this.getClass(), "Closed WebSocketServer " + webSocketServer.domain + ":" + webSocketServer.port + " for UI: " + this);
        } catch (Exception e) {
        }
        try {
            httpServer.server.stop();
            AL.debug(this.getClass(), "Closed HTTPServer " + httpServer.serverDomain + ":" + httpServer.serverPort + " for UI: " + this);
        } catch (Exception e) {
        }
        AL.debug(this.getClass(), "Closed " + this);
    }

    /**
     * Creates a snapshot of the current UI (the full HTML page) <br>
     * and returns it as {@link Document} for further processing. <br>
     * Note that changes to it won't be reflected in the actual UI.
     */
    public Document getSnapshot() {
        if (content.element.parent() == null) {
            // First load
            Document html = route.getBaseDocument();

            // Append additional styles
            Element elGlobalCSSLink = new Element("link");
            elGlobalCSSLink.attr("rel", "stylesheet");
            elGlobalCSSLink.attr("href", App.styles.getName());
            html.getElementsByTag("head").get(0).appendChild(elGlobalCSSLink);

            // Append theme
            Element elThemeCSS = new Element("style");
            elThemeCSS.html("\n" +
                    App.theme.toCSS() +
                    "    body, #outlet {\n" +
                    "      height: 100vh;\n" +
                    "      width: 100%;\n" +
                    "      margin: 0;\n" +
                    "    }\n" +
                    "\n");
            html.getElementsByTag("head").get(0).appendChild(elThemeCSS);


            // Append actual content
            Element outlet = html.getElementById("outlet");
            content.updateAll();
            outlet.appendChild(content.element);

            Element jsOnPageLoaded = new Element("script");
            jsOnPageLoaded.html("function onPageLoaded(callback) {\n" +
                    "  async function notifyOnPageLoad() {\n" +
                    "    if (document.readyState === 'complete') {\n" +
                    //"      console.log('Page finished loading.');\n" +
                    "      callback();\n" +
                    "    } else {\n" +
                    "      setTimeout(notifyOnPageLoad, 100); // 100ms\n" +
                    "    }\n" +
                    "  }\n" +
                    "\n" +
                    //"  console.log('Waiting for page to finish loading...');\n" +
                    "  notifyOnPageLoad(); // Perform the initial check immediately\n" +
                    "}\n\n" +
                    "window.onPageLoaded = onPageLoaded;\n");
            html.getElementsByTag("body").get(0).appendChild(jsOnPageLoaded);

            // Execute global JS code to ensure dependencies are loaded
            Element elGlobalJSLink = new Element("script");
            elGlobalJSLink.attr("src", App.javascript.getName());
            html.getElementsByTag("body").get(0).appendChild(elGlobalJSLink);

            // Notify Java that we are ready to execute JavaScript
            Element elJSConnectToBackendWS = new Element("script");
            elJSConnectToBackendWS.html("onPageLoaded(() => {\n"
                                    +webSocketServer.jsStartWebSocketClient(webSocketServer.domain, webSocketServer.port)
                                    +"\n});\n");
            html.getElementsByTag("body").get(0).appendChild(elJSConnectToBackendWS);
            return html;
        } else {
            content.updateAll();
            Element html = content.element;
            while ((html = html.parent()) != null) ;
            return (Document) html;
        }
    }

    /**
     * @see #snapshotToTempFile(Document)
     */
    public File snapshotToTempFile() throws IOException {
        return snapshotToTempFile(null);
    }

    /**
     * Creates a snapshot and writes the HTML to a file in the temp folder of the current user. <br>
     * If the path for this route is "/persons/john" for example then the html file will be created at: <br>
     * {@link App#tempDir}/{@link #hashCode()}/persons/john.html <br>
     * Note that the hash code is in hex format.
     *
     * @return the generated html file.
     */
    public File snapshotToTempFile(Document snapshot) throws IOException {
        File file = getSnapshotTempFile();
        if (snapshot == null) snapshot = getSnapshot();

        // Write html to temp file
        AL.debug(this.getClass(), "Generate: " + file);
        file.getParentFile().mkdirs();
        if (!file.exists()) file.createNewFile();
        Files.write(file.toPath(), snapshot.outerHtml().getBytes(StandardCharsets.UTF_8));
        return file;
    }

    public File getSnapshotTempFile() {
        return new File(App.htmlDir
                + (route.path.equals("/") || route.path.isEmpty() ? "/.html" : (route.path + ".html")));
    }

    /**
     * @see #width(int)
     */
    public void widthFull() throws InterruptedException, InvocationTargetException {
        width(100);
    }

    /**
     * @see #height(int)
     */
    public void heightFull() throws InterruptedException, InvocationTargetException {
        height(100);
    }

    /**
     * Note that this method is meant to be used internally. <br>
     * Use {@link #navigate(Class)} instead if you want to send the
     * user to another page.
     */
    public void z_internal_load(Class<? extends Route> routeClass) throws IOException {
        Route route = null;
        for (Route r : App.routes) {
            if (r.getClass().equals(routeClass)) {
                route = r;
                break;
            }
        }
        if (route == null) { // Route was not registered
            AL.warn("Failed to load page, since provided route '" + routeClass
                    + "' was not registered, aka not added to App.routes!", new Exception());
            return;
        }
        UI.set(this, Thread.currentThread());
        this.isLoading.set(true);
        this.route = route;
        this.listenersAndComps.clear();
        this.content = route.loadContent();
        this.content.setAttached(true);
        this.content.forEachChildRecursive(child -> {
            child.setAttached(true);
        });
        UI.remove(Thread.currentThread());
    }

    // JS LISTENER


    /**
     * @see #registerJSListener(String, Component, String, Consumer)
     */
    public UI registerDocJSListener(String eventName, String jsOnEvent, Consumer<String> onEvent) {
        return registerJSListener(eventName, null, jsOnEvent, onEvent);
    }

    /**
     * @see #registerJSListener(String, Component, String, Consumer)
     */
    public UI registerJSListener(String eventName, Component comp, Consumer<String> onEvent) {
        return registerJSListener(eventName, comp, "", onEvent);
    }


    /**
     * Registers this listener directly only if the page was loaded,
     * otherwise adds an action to {@link #onLoadStateChanged} to register the listener later.<br>
     * <br>
     * {@link WarnDoc#might_return_javascript_exception_message}
     *
     * @param eventName name of the JavaScript event to listen for.
     * @param comp      component to register the listener on. If null, document will be used as component.
     * @param jsOnEvent additional JavaScript code that is run when the event is triggered and has access
     *                  to the variables:  <br>
     *                  message: which is the string that is returned to Java and contains the event as json object. <br>
     *                  event: which is the event object. <br>
     * @param onEvent   executed when event happened. Has {@link #access(Runnable)}.
     */
    public UI registerJSListener(String eventName, Component comp, String jsOnEvent, Consumer<String> onEvent) {
        synchronized (listenersAndComps) {
            List<Component<?, ?>> alreadyRegisteredComps = listenersAndComps.get(eventName);
            if (alreadyRegisteredComps == null) {
                alreadyRegisteredComps = new ArrayList<>();
                listenersAndComps.put(eventName, alreadyRegisteredComps);
            }
            if (alreadyRegisteredComps.contains(comp))
                return this; // Already registered
            alreadyRegisteredComps.add(comp);
        }
        String jsNow =
                "comp.addEventListener(\"" + eventName + "\", (event) => {\n" +
                        webSocketServer.addPermanentCallback(this, "function getObjProps(obj) {\n" +
                                        "  var json = '{';\n" +
                                        "  for (const key in obj) {\n" +
                                        "    if (obj[key] !== obj && obj[key] !== null && obj[key] !== undefined) {\n" +
                                        "      if(key == 'data') continue;\n" + // Skip data since it's the same as value
                                        "      json += (`\"${key}\": \"${obj[key]}\",`);\n" + // Also hope that values do not contain JSON breaking chars
                                        "    }\n" +
                                        "  }\n" +
                                        "  if(json[json.length-1] == ',') json = json.slice(0, json.length-1);" + // Remove last ,
                                        "  json += '}';\n" +
                                        "  return json;\n" +
                                        "}" +
                                        "message = getObjProps(event)\n" +
                                        jsOnEvent,
                                (result) -> {
                                    App.executor.execute(() -> { // async
                                        access(() -> {
                                            try {
                                                onEvent.accept(result.message); // Should execute all listeners
                                            } catch (Exception e) {
                                                AL.warn(e);
                                            }
                                        });
                                    });
                                }).jsCode + // JS code that triggers Java function gets executed on a click event for this component
                        "});\n";

        if (!isLoading.get()) {
            if (comp == null) executeJavaScriptSafely("let comp = document\n" + jsNow, "internal", 0);
            else comp.executeJS(this, jsNow);
        } else onLoadStateChanged.addAction((action, isLoading) -> {
            if (isLoading) return;
            action.remove();
            if (comp == null) executeJavaScriptSafely("let comp = document\n" + jsNow, "internal", 0);
            else comp.executeJS(this, jsNow);
        }, AL::warn);
        return this;
    }


    // JS OBSERVER


    /**
     * @see #registerJSObserver(JsObserverType, Component, String, String, Consumer)
     */
    public UI registerDocJSObserver(JsObserverType observerType, String config, String jsOnObserve,
                                    Consumer<String> onObserve) {
        return registerJSObserver(observerType, null, config, jsOnObserve, onObserve);
    }

    /**
     * @see #registerJSObserver(JsObserverType, Component, String, String, Consumer)
     */
    public UI registerJSObserver(JsObserverType observerType, Component comp, String config,
                                 Consumer<String> onObserve) {
        return registerJSObserver(observerType, comp, config, "", onObserve);
    }

    public static enum JsObserverType{
        MUTATION, RESIZE, INTERSECTION, PERFORMANCE
    }

    /**
     * Registers a JavaScript observer of any supported type on a component.
     * Supports MutationObserver, ResizeObserver, IntersectionObserver, and PerformanceObserver.<br>
     * <br>
     * {@link WarnDoc#might_return_javascript_exception_message}
     *
     * @param observerType  type of observer to create ("mutation", "resize", "intersection", "performance")
     * @param comp         component to register the observer on. If null, document.body will be used (except for PerformanceObserver)
     * @param config      observer configuration object as a JSON string. Format depends on observer type:
     *                    - MutationObserver: {"attributes": true, "childList": true, ...}
     *                    - ResizeObserver: {} (empty object, uses default config)
     *                    - IntersectionObserver: {"threshold": [0, 0.5, 1], "rootMargin": "0px"}
     *                    - PerformanceObserver: {"entryTypes": ["layout-shift", "largest-contentful-paint"]}
     * @param jsOnObserve additional JavaScript code that runs when changes are detected
     * @param onObserve   executed when changes are detected. Has {@link #access(Runnable)}.
     */
    public UI registerJSObserver(JsObserverType observerType, Component comp, String config, String jsOnObserve,
                                 Consumer<String> onObserve) {
        synchronized (listenersAndComps) {
            String key = observerType + "-" + config;
            List<Component<?, ?>> alreadyObservedComps = listenersAndComps.get(key);
            if (alreadyObservedComps == null) {
                alreadyObservedComps = new ArrayList<>();
                listenersAndComps.put(key, alreadyObservedComps);
            }
            if (alreadyObservedComps.contains(comp))
                return this; // Already registered
            alreadyObservedComps.add(comp);
        }

        String observerCreation;
        switch (observerType) {
            case MUTATION:
                observerCreation = "new MutationObserver";
                break;
            case RESIZE:
                observerCreation = "new ResizeObserver";
                break;
            case INTERSECTION:
                observerCreation = "new IntersectionObserver";
                break;
            case PERFORMANCE:
                observerCreation = "new PerformanceObserver";
                break;
            default:
                throw new IllegalArgumentException("Unsupported observer type: " + observerType);
        }

        String getPropsFunction = "function getObserverProps(entries) {\n" +
                "    if (!Array.isArray(entries)) entries = [entries];\n" +
                "    return entries.map(entry => {\n" +
                "        var json = '{';\n" +
                "        const props = {\n" +
                "            // Common properties\n" +
                "            type: entry.type,\n" +
                "            timestamp: entry.timestamp,\n" +
                "\n" +
                "            // MutationObserver specific\n" +
                "            target: entry.target?.tagName,\n" +
                "            addedNodes: entry.addedNodes?.length,\n" +
                "            removedNodes: entry.removedNodes?.length,\n" +
                "            attributeName: entry.attributeName,\n" +
                "            oldValue: entry.oldValue,\n" +
                "\n" +
                "            // ResizeObserver specific\n" +
                "            contentRect: entry.contentRect ?\n" +
                "                '' + entry.contentRect.width + 'x' + entry.contentRect.height : undefined,\n" +
                "            borderBoxSize: entry.borderBoxSize?.[0] ?\n" +
                "                '' + entry.borderBoxSize[0].inlineSize + 'x' + entry.borderBoxSize[0].blockSize : undefined,\n" +
                "\n" +
                "            // IntersectionObserver specific\n" +
                "            intersectionRatio: entry.intersectionRatio,\n" +
                "            isIntersecting: entry.isIntersecting,\n" +
                "\n" +
                "            // PerformanceObserver specific\n" +
                "            entryType: entry.entryType,\n" +
                "            name: entry.name,\n" +
                "            startTime: entry.startTime,\n" +
                "            duration: entry.duration\n" +
                "        };\n" +
                "\n" +
                "        for (const key in props) {\n" +
                "            if (props[key] !== null && props[key] !== undefined) {\n" +
                "                json += (`\"${key}\": \"${props[key]}\",`);\n" +
                "            }\n" +
                "        }\n" +
                "        if(json[json.length-1] == ',') json = json.slice(0, json.length-1);\n" +
                "        json += '}';\n" +
                "        return json;\n" +
                "    });\n" +
                "}\n";

        String jsNow = observerCreation + "((entries, observer) => {\n" +
                webSocketServer.addPermanentCallback(this,
                        getPropsFunction +
                                "message = getObserverProps(entries)\n" +
                                jsOnObserve,
                        (result) -> {
                            App.executor.execute(() -> { // async
                                access(() -> {
                                    try {
                                        onObserve.accept(result.message);
                                    } catch (Exception e) {
                                        AL.warn(e);
                                    }
                                });
                            });
                        }
                ).jsCode + ");\n";

        // Add observer-specific initialization
        switch (observerType) {
            case MUTATION: jsNow += "observer.observe(comp, " + config + ");\n"; break;
            case RESIZE: jsNow += "observer.observe(comp);\n"; break;
            case INTERSECTION: jsNow += "observer.observe(comp, " + config + ");\n"; break;
            case PERFORMANCE: jsNow += "observer.observe(" + config + ");\n"; break;
        }

        if (!isLoading.get()) {
            if (comp == null) {
                if(observerType == JsObserverType.PERFORMANCE) throw new IllegalArgumentException("Observer cannot be of type performance if registering on document instead of a component!");
                executeJavaScriptSafely("let comp = document.body\n" + jsNow, "internal", 0);
            } else {
                comp.executeJS(this, jsNow);
            }
        } else {
            String finalJsNow = jsNow;
            onLoadStateChanged.addAction((action, isLoading) -> {
                if (isLoading) return;
                action.remove();
                if (comp == null) {
                    if(observerType == JsObserverType.PERFORMANCE) throw new IllegalArgumentException("Observer cannot be of type performance if registering on document instead of a component!");
                    executeJavaScriptSafely("let comp = document.body\n" + finalJsNow, "internal", 0);
                } else {
                    comp.executeJS(this, finalJsNow);
                }
            }, AL::warn);
        }
        return this;
    }

    public void startHTTPServer() throws Exception {
        int freePort = App.httpServerPort;
        while (freePort == -1) {
            try (ServerSocket serverSocket = new ServerSocket(0)) {
                // Set the port to 0 to let the system allocate a free port
                freePort = serverSocket.getLocalPort();
            }
            if (new UnsafePortChrome().getPorts().contains(freePort)) freePort = -1;
        }

        startHTTPServer(App.domainName, freePort);
    }

    public synchronized void startHTTPServer(String serverDomain, int serverPort) throws Exception {
        httpServer = new HTTPServer(this, serverDomain, serverPort);
        serverPort = httpServer.serverPort;
        AL.debug(this.getClass(), "Started HTTPServer " + serverDomain + ":" + serverPort + " for UI: " + this);
    }

    /**
     * Uses {@link App#domainName} and searches for a random free port
     * (if {@link App#webSocketServerPort} is -1) to use for the WebSocketServer.
     */
    public void startWebSocketServer() throws Exception {
        int freePort = App.webSocketServerPort;
        if (freePort == -1)
            try (ServerSocket serverSocket = new ServerSocket(0)) {
                // Set the port to 0 to let the system allocate a free port
                freePort = serverSocket.getLocalPort();
            }
        startWebSocketServer(App.domainName, freePort);
    }

    /**
     * Returns JS code that when executed on the client browser creates a WebSocket connection.
     * Also creates and inits the WebSocketServer if needed.
     *
     * @param serverDomain
     * @param serverPort
     * @return
     */
    public synchronized void startWebSocketServer(String serverDomain, int serverPort) throws Exception {
        webSocketServer = new JSWebSocketServer(serverDomain, serverPort) {
            @Override
            public void onOpen(WebSocket conn, ClientHandshake handshake) {
                super.onOpen(conn, handshake);
                // Executed when client connects, since its executed at the end of the HTML body
                // this tells us that the page is loaded for the first time too
                AL.debug(this.getClass(), this + " init success!");
                onLoadStateChanged.execute(false);
            }
        };
        serverPort = webSocketServer.port;
        AL.debug(this.getClass(), "Started WebSocketServer " + serverDomain + ":" + serverPort + " for UI: " + this);
    }

    public boolean isOpen() {
        return httpServer != null && httpServer.server.isAlive();
    }

    public String jsGetComp(String varName, int id) {
        return "var " + varName + " = document.querySelector('[java-id=\"" + id + "\"]');\n";
    }

    /**
     * Returns a list of mainly unattached parents (the last element is the first attached parent that is found), starting from the given comp and moving up the hierarchy.
     * The list is in order from child to parent. <br>
     * <br>
     * @throws InvalidParentException if the last comp is not attached. Meaning the component probably was never added to a parent on the Java side.
     */
    private List<Component> getParentChain(Component startElement) throws InvalidParentException {
        List<Component> parents = new ArrayList<>();
        MyElement current = startElement.element;

        while (current != null && current instanceof MyElement) {
            parents.add(current.comp);
            if (current.comp.isAttached()) break;

            Element parent = current.parent();
            if (parent == null || !(parent instanceof MyElement)){
                throw new InvalidParentException("Parent is invalid/null, possibly meaning that the component was never added to a parent on the Java side." +
                "However it can also mean that update() was never called before. comp="+current.comp.toPrintString()+" parent="+parent+" ");
            }
            current = (MyElement) parent;
        }

        return parents;
    }

    public class InvalidParentException extends Exception{
        public InvalidParentException(String message) {
            super(message);
        }
    }

    public <T extends Component<?, ?>> Event<JavaScriptResult> attachToParent(Component<?, ?> parent, Component<?, ?> child, Component.AddedChildEvent e) {
        if (child.isAttached()) {
            AL.debug(getClass(), "Skipping attachToParent: child already attached: " + child.toPrintString());
            var event = new Event<JavaScriptResult>(true);
            //event.execute(new JavaScriptResult("", true)); // Do NOT re-execute the attached event
            return event;
        }


        if(App.isInDepthDebugging) {
            StringWriter s = new StringWriter();
            new Exception().printStackTrace(new PrintWriter(s));
            AL.debug(this.getClass(), "attachToParent() parent = "+parent.toPrintString()+" attached="+parent.isAttached()+" added child = "+
                    child.toPrintString()+" child html = \n"+ child.element.outerHtml()+"\n "+s.toString());
        }
        if(!parent.isAttached())
            throw new RuntimeException("Attempting attach to parent even though parent '"+parent.toPrintString()+"' is not attached yet!");

        if (e.otherChildComp == null) { // add
            var event = executeJavaScriptSafely(jsAttachToParent(parent, child),
                    "internal", 0);
            event.addAction(result -> {
                child.setAttached(true);
                child.forEachChildRecursive(child2 -> {
                    child2.setAttached(true);
                });
            });
            return event;
        } else { //if (e.isInsert || e.isReplace) { // for replace, remove() must be executed after this function returns
            // if replace: childComp is the new component to be added and otherChildComp is the one that gets removed/replaced
            // "beforebegin" = Before the element. Only valid if the element is in the DOM tree and has a parent element.
            var event = executeJavaScriptSafely(
                    jsGetComp("otherChildComp", e.otherChildComp.id) +
                            "var child = `" + Value.escapeForJavaScript(Value.escapeForJSON(e.childComp.element.outerHtml())) + "`;\n" +
                            "otherChildComp.insertAdjacentHTML(\"beforebegin\", child);\n" +
                            (App.isInDepthDebugging ? "console.log('otherChildComp:', otherChildComp); console.log('➡️✅ inserted child:', child); \n" : ""),
                    "internal", 0);
            event.addAction(result -> {
                e.childComp.setAttached(true);
                e.childComp.forEachChildRecursive(child2 -> {
                    child2.setAttached(true);
                });
            });
            return event;
        }
    }

    public String jsAttachToParent(Component<?, ?> parent, Component<?, ?> child) {
        return "try{" + jsGetComp("parentComp", parent.id) +
                "var child = `\n" + Value.escapeForJavaScript(Value.escapeForJSON(child.element.outerHtml())) + "\n`;\n" +
                "parentComp.insertAdjacentHTML(\"beforeend\", child);\n" +
                (App.isInDepthDebugging ? "console.log('parentComp:', parentComp); console.log('➡️✅ added child:', child);\n" : "") +
                "\n}catch(e){console.error(e)}";
    }

    public void runIfReadyOrLater(Runnable code) {
        synchronized (isLoading){
            if (!isLoading.get()) code.run();
            else onLoadStateChanged.addAction((action, isLoading) -> {
                if (isLoading) return;
                action.remove();
                code.run();
            }, AL::warn);
        }
    }

    public void runIfReadyAndCompAttachedOrLater(Component<?, ?> comp, Runnable code) {
        synchronized (isLoading){
            if (!isLoading.get() && comp.isAttached()) code.run();
            else onLoadStateChanged.addAction((action, isLoading) -> {
                if (isLoading && !comp.isAttached()) return;
                action.remove();
                code.run();
            }, AL::warn);
        }
    }

    public boolean isLoading(){
        synchronized (isLoading){
            return isLoading.get();
        }
    }
}
